<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet exclude-result-prefixes="xs" version="2.0"
    xmlns:b64="https://github.com/ilyakharlamov/xslt_base64" xmlns:bin="http://expath.org/ns/binary"
    xmlns:html="http://www.w3.org/1999/xhtml" xmlns:oap="https://openarabicpe.github.io/ns"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    xmlns:tss="http://www.thirdstreetsoftware.com/SenteXML-1.0"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output encoding="UTF-8" indent="yes" method="xml" omit-xml-declaration="no"/>
    <!-- this stylesheet transforms generic XML generated by exporting tables from Sente libraries using SQLiteStudio. Names of the XML files must mirror the names of the SQLite tables -->
    <!-- input is currently a list of reference UUIDs from Reference.xml. Since the stylesheet explicitly pulls in all relevant source files, this can easily be changed to any other source of reference UUIDs -->
    <!-- output is currently a single Sente XML file for all references. Using the modular templates in this stylesheet, this can easily be changed to generate one file for every reference -->
    <xsl:param name="p_limited-to-saxon-he" select="true()"/>
    <xsl:param name="p_debug" select="true()"/>
    <xsl:param name="p_cut-off-date" select="'2001-01-01'"/>
    <xsl:variable name="v_input-folder" select="replace(base-uri(), '(.+/).+?\.xml', '$1')"/>
    <!-- select and load the input files into memory -->
    <xsl:variable name="v_file-attachments" select="document(concat($v_input-folder, 'Attachment.xml'))"/>
    <xsl:variable name="v_file-attachment-locations" select="document(concat($v_input-folder, 'AttachmentLocation.xml'))"/>
    <xsl:variable name="v_file-authors" select="document(concat($v_input-folder, 'Author.xml'))"/>
    <xsl:variable name="v_file-keywords" select="document(concat($v_input-folder, 'Keyword.xml'))"/>
    <xsl:variable name="v_file-notes" select="document(concat($v_input-folder, 'Note.xml'))"/>
    <xsl:variable name="v_file-references" select="document(concat($v_input-folder, 'Reference.xml'))"/>
    <xsl:variable name="v_file-sparse-attributes" select="document(concat($v_input-folder, 'SparseAttribute.xml'))"/>
    
    <!-- static variables for all references -->
    <xsl:variable name="v_base-url"
        select="substring-before(document(concat($v_input-folder, 'LibraryProperty.xml'))/table/rows/row[value[@column = '0'] = 'Library Location']/value[@column = '1'], 'primaryLibrary.sente601')"/>
    <!-- bibliographic information from Reference.xml -->
    <xsl:variable name="v_columns" select="'4,5,6,7,8,10,11,14,20'"/>
    <xsl:variable name="v_column-names"
        select="document(concat($v_input-folder, 'Reference.xml'))/table/columns"/>
    <!-- check the column number for specific fields in 'Notes.xml'. This is necessary as the sort order can change -->
    <xsl:variable name="v_column-notes-isDeleted" select="count($v_file-notes/table/columns/column[name='IsDeleted']/preceding-sibling::column)"/>
    <xsl:variable name="v_column-notes-dateModified" select="count($v_file-notes/table/columns/column[name='DateModified']/preceding-sibling::column)"/>
    <xsl:variable name="v_column-notes-annotationDetails" select="count($v_file-notes/table/columns/column[name='AnnotationDetails']/preceding-sibling::column)"/>
    <xsl:variable name="v_column-notes-attachmentUUID" select="count($v_file-notes/table/columns/column[name='AttachmentUUID']/preceding-sibling::column)"/>
    <xsl:variable name="v_column-notes-lastEditingUser" select="count($v_file-notes/table/columns/column[name='LastEditingUser']/preceding-sibling::column)"/>
    <xsl:variable name="v_column-notes-locationInAttachedFile" select="count($v_file-notes/table/columns/column[name='LocationInAttachedFile']/preceding-sibling::column)"/>
    <!-- check the column number for specific fields in 'Attachment.xml'. This is necessary as the sort order can change -->
    <xsl:variable name="v_column-attachments-isDeleted" select="count($v_file-attachments/table/columns/column[name='IsDeleted']/preceding-sibling::column)"/>
    <xsl:variable name="v_column-attachments-attachmentType" select="count($v_file-attachments/table/columns/column[name='AttachmentType']/preceding-sibling::column)"/>
    <xsl:variable name="v_column-attachments-dateModified" select="count($v_file-attachments/table/columns/column[name='dateModified']/preceding-sibling::column)"/>
    <xsl:variable name="v_column-attachments-lastEditingUser" select="count($v_file-attachments/table/columns/column[name='LastEditingUser']/preceding-sibling::column)"/>
    <xsl:variable name="v_column-attachments-attachmentName" select="count($v_file-attachments/table/columns/column[name='AttachmentName']/preceding-sibling::column)"/>
        
    <xsl:template match="/">
        <xsl:result-document href="_output/compiled-cut-off_{$p_cut-off-date}.TSS.xml">
            <!-- group by PrimaryReferenceUUID in  -->
            <tss:senteContainer>
                <tss:library>
                    <tss:references>
                        <!-- exclude all references modified before the cut-off date -->
                        <xsl:for-each-group group-by="value[@column = '0']" select="table/rows/row[oap:iso-date(value[@column = '19']) &gt;= $p_cut-off-date]">
                            <!-- sort by modification date -->
                            <xsl:sort order="descending"
                                select="current-group()/value[@column = '19']"/>
                            <xsl:call-template name="t_generate-references">
                                <xsl:with-param name="p_reference-uuid"
                                    select="current-grouping-key()"/>
                            </xsl:call-template>
                        </xsl:for-each-group>
                    </tss:references>
                </tss:library>
            </tss:senteContainer>
        </xsl:result-document>
    </xsl:template>
    <xsl:template name="t_generate-references">
        <xsl:param name="p_reference-uuid"/>
        <xsl:for-each
            select="$v_file-references/table/rows/row[value[@column = '0'] = $p_reference-uuid]">
            <!-- set a number of general variables -->
            <xsl:variable name="v_spares-attributes"
                select="document(concat($v_input-folder, 'SparseAttribute.xml'))/table/rows/row[value[@column = '0'] = $p_reference-uuid]"/>
            <tss:reference xml:id="{concat('uuid_',$p_reference-uuid)}">
                <tss:publicationType name="{value[@column='3']}"/>
                <!-- authors -->
                <xsl:call-template name="t_generate-authors">
                    <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
                </xsl:call-template>
                <tss:dates>
                    <!-- publication dates are stored in three different rows to account for technically false dates -->
                    <tss:date day="{value[@column='17']}" month="{value[@column='16']}"
                        type="Publication" year="{value[@column='15']}"/>
                    <!-- column 18: date of entry / date, a reference was added to Sente. Very early references do not carry a value  -->
                    <xsl:if test="value[@column = '18'] != ''">
                        <xsl:variable name="v_date-entry"
                            select="oap:iso-date(value[@column = '18'])"/>
                        <tss:date day="{day-from-date($v_date-entry)}"
                            month="{month-from-date($v_date-entry)}" type="Entry"
                            year="{year-from-date($v_date-entry)}"/>
                    </xsl:if>
                    <!-- column 19: date of last modification -->
                    <xsl:if test="value[@column = '19'] != ''">
                        <xsl:variable name="v_date-modified"
                            select="oap:iso-date(value[@column = '19'])"/>
                        <tss:date day="{day-from-date($v_date-modified)}"
                            month="{month-from-date($v_date-modified)}" type="Modification"
                            year="{year-from-date($v_date-modified)}"/>
                    </xsl:if>
                    <tss:date
                        day="{$v_spares-attributes/self::row[value[@column='1']='Retrieval day']/value[@column='2']}"
                        month="{$v_spares-attributes/self::row[value[@column='1']='Retrieval month']/value[@column='2']}"
                        type="Retrieval"
                        year="{$v_spares-attributes/self::row[value[@column='1']='Retrieval year']/value[@column='2']}"
                    />
                </tss:dates>
                <tss:characteristics>
                    <tss:characteristic name="UUID">
                        <xsl:value-of select="$p_reference-uuid"/>
                    </tss:characteristic>
                    <!-- add all relevant bibliographic fields -->
                    <!-- we need columns 4-8, 10-11,14, 20. Since this information does not depend on context, we can put them outside of individual templates -->
                    <!--<xsl:variable name="v_columns" select="'4,5,6,7,8,10,11,14,20'"/>
                    <xsl:variable name="v_column-names" select="ancestor::table/columns"/>-->
                    <xsl:for-each select="value">
                        <xsl:if test="tokenize($v_columns, ',') = @column">
                            <xsl:variable name="v_column-no" select="number(@column)"/>
                            <tss:characteristic
                                name="{$v_column-names/self::columns/column[$v_column-no +1]/name}">
                                <xsl:value-of select="."/>
                            </tss:characteristic>
                        </xsl:if>
                    </xsl:for-each>
                    <!-- add aditional fields kept in SparseAttribute.xml, including but not limited to custom fields -->
                    <xsl:call-template name="t_generate-characteristics">
                        <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
                    </xsl:call-template>
                </tss:characteristics>
                <xsl:call-template name="t_generate-keywords">
                    <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
                </xsl:call-template>
                <xsl:call-template name="t_generate-notes">
                    <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
                </xsl:call-template>
                <xsl:call-template name="t_generate-attachments">
                    <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
                </xsl:call-template>
            </tss:reference>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="t_generate-characteristics">
        <!-- the template takes a reference UUID as input and queries the SparseAttribute.xml file for any rows relating to this reference -->
        <xsl:param name="p_reference-uuid"/>
        <!--        <xsl:param name="p_input" select="document(concat($v_input-folder, 'SparseAttribute.xml'))/table/rows/row[value[@column = '0'] = $p_reference-uuid]"/>-->
        <xsl:for-each
            select="$v_file-sparse-attributes/table/rows/row[value[@column = '0'] = $p_reference-uuid]">
            <!-- exclude certain rows -->
            <xsl:if
                test="not(value[@column = '1'] = ('Retrieval year', 'Retrieval month', 'Retrieval day'))">
                <tss:characteristic name="{value[@column='1']}">
                    <xsl:value-of select="value[@column = '2']"/>
                </tss:characteristic>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="t_generate-notes">
        <!-- the template takes a reference UUID as input and queries the Note.xml file for any rows relating to this reference -->
        <xsl:param name="p_reference-uuid"/>
        <tss:notes>
            <!-- Sente does not ultimately delete any note. Therefore one has to actively check for the status of a row in column 10: IsDeleted. -->
            <!-- In addition, the Note.xml file also contains all notes attached to references long since deleted, which, however, will not be marked as having been deleted themselves -->
            <xsl:for-each
                select="$v_file-notes/table/rows/row[value[@column = '1'] = $p_reference-uuid][value[@column = $v_column-notes-isDeleted] = 'N']">
                <xsl:variable name="v_color-rgba">
                    <xsl:analyze-string regex="RGBA.+?\[(.+?)\]" select="value[@column = $v_column-notes-annotationDetails]">
                        <xsl:matching-substring>
                            <xsl:value-of select="regex-group(1)"/>
                        </xsl:matching-substring>
                    </xsl:analyze-string>
                </xsl:variable>
                <!-- translate rgba to colour names -->
                <xsl:variable name="v_color">
                    <xsl:choose>
                        <xsl:when test="$v_color-rgba = '0.9960784,0.8745098,0,0.2'">
                            <xsl:text>yellow</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '1,0.3137255,0.3137255,0.2'">
                            <xsl:text>red</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '0.3921569,0.627451,0.7843137,0.2'">
                            <xsl:text>blue</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '0.4392157,0.6431373,0.5372549,0.2'">
                            <xsl:text>green</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '0.5764706,0.3137255,0.6196079,0.2'">
                            <xsl:text>purple</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '0.9647059,0.572549,0.2509804,0.2'">
                            <xsl:text>orange</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>unknown</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <!-- Sente uses different RGBA values for macOS and iOS. We can therefore establish the OS based on the RGBA value. -->
                <xsl:variable name="v_input-os">
                    <xsl:choose>
                        <xsl:when
                            test="$v_color-rgba = ('0.9960784,0.8745098,0,0.2', '1,0.3137255,0.3137255,0.2', '0.3921569,0.627451,0.7843137,0.2', '0.4392157,0.6431373,0.5372549,0.2', '0.5764706,0.3137255,0.6196079,0.2', '0.9647059,0.572549,0.2509804,0.2')">
                            <xsl:text>macOS</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>iOS</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:variable name="v_type">
                    <xsl:analyze-string regex="Original Selection Mode&quot;:&quot;(.+?)&quot;"
                        select="value[@column = $v_column-notes-annotationDetails]">
                        <xsl:matching-substring>
                            <xsl:value-of select="lower-case(regex-group(1))"/>
                        </xsl:matching-substring>
                    </xsl:analyze-string>
                </xsl:variable>
                <tss:note>
                    <xsl:attribute name="xml:id" select="concat('uuid_', value[@column = '0'])"/>
                    <!-- this is redundant since <tss:notes> is a direct child of the <tss:reference> this attribute refers to -->
<!--                    <xsl:attribute name="correspReference" select="concat('#uuid_', $p_reference-uuid)"/>-->
                    <xsl:attribute name="correspAttachment"
                        select="concat('#uuid_', value[@column = $v_column-notes-attachmentUUID])"/>
                    <xsl:attribute name="editor"
                        select="concat('Sente User ', value[@column = $v_column-notes-lastEditingUser])"/>
                    <xsl:attribute name="color" select="$v_color"/>
                    <xsl:attribute name="inputOs" select="$v_input-os"/>
                    <xsl:attribute name="when-iso" select="oap:iso-timestamp(value[@column = $v_column-notes-dateModified])"/>
                    <!-- some css based on the JSON data stream -->
                    <xsl:choose>
                        <xsl:when test="$v_type = 'text'">
                            <xsl:attribute name="style">
                                <xsl:text>display:inline-block;</xsl:text>
                                <xsl:text>background-color: rgba(</xsl:text>
                                <xsl:value-of select="$v_color-rgba"/>
                                <xsl:text>);</xsl:text>
                            </xsl:attribute>
                        </xsl:when>
                        <xsl:when test="$v_type = 'region'">
                            <xsl:attribute name="style">
                                <!-- border radius and stroke width are always the same -->
                                <xsl:text>display:block; border-style:solid; border-radius: 3px; border-width: 4px; </xsl:text>
                                <xsl:text>border-color: rgba(</xsl:text>
                                <xsl:value-of select="$v_color-rgba"/>
                                <xsl:text>);</xsl:text>
                            </xsl:attribute>
                        </xsl:when>
                    </xsl:choose>
                    <title>
                        <xsl:value-of select="value[@column = '2']"/>
                    </title>
                    <comment>
                        <xsl:value-of select="value[@column = '5']"/>
                    </comment>
                    <quotation>
                        <xsl:value-of select="value[@column = '4']"/>
                    </quotation>
                    <pages>
                        <xsl:value-of select="value[@column = '3']"/>
                    </pages>
                    <!-- custom elements mirroring the column name in the SQLite source -->
                    <!-- column 8: position in attached file -->
                    <locationInAttachedFile>
                        <xsl:value-of select="value[@column = $v_column-notes-locationInAttachedFile]"/>
                    </locationInAttachedFile>
                    <!-- column 9: annotation details; JSON including geometry, position on page, colour, strike etc. -->
                    <annotationDetails>
                        <xsl:value-of select="value[@column = $v_column-notes-annotationDetails]"/>
                    </annotationDetails>
                </tss:note>
            </xsl:for-each>
        </tss:notes>
    </xsl:template>
    <xsl:template name="t_generate-attachments">
        <!-- the template takes a reference UUID as input and queries the Attachment.xml file for any rows relating to this reference -->
        <xsl:param name="p_reference-uuid"/>
        <!--        <xsl:param name="p_input" select="document(concat($v_input-folder, 'Attachment.xml'))/table/rows/row[value[@column = '0'] = $p_reference-uuid]"/>-->
        <tss:attachments>
            <!-- Sente does not ultimately delete any attachment reference from Attachment.xml. Therefore one has to actively check for the status of a row in column 5: IsDeleted. -->
            <xsl:for-each
                select="$v_file-attachments/table/rows/row[value[@column = '0'] = $p_reference-uuid][value[@column = $v_column-attachments-isDeleted] = 'N']">
                <xsl:variable name="v_type" select="value[@column = $v_column-attachments-attachmentType]"/>
                <xsl:variable name="v_editor" select="concat('Sente User ', value[@column = $v_column-attachments-lastEditingUser])"/>
                <xsl:variable name="v_date-edited" select="oap:iso-timestamp(value[@column = $v_column-attachments-dateModified])"/>
                <xsl:variable name="v_name" select="value[@column = $v_column-attachments-attachmentName]"/>
                <xsl:variable name="v_attachment-uuid" select="value[@column = '1']"/>
                <xsl:variable name="v_attachment-location"
                    select="$v_file-attachment-locations/table/rows/row[value[@column = '1'] = $v_attachment-uuid]"/>
                <!-- there is a huge issue with the attachment UUIDs in AttachmentLocation.xml: they are not unique! Depending on how many version of a file, Sente keeps track of, 
                    the number is potentially unlimited. I have seen at least five entires for the same attachment UUID. One could generate a `<tss:attachmentReference>` for each
                    The values for @column='3' are:
                        1. "Replication Server": synced to the Sente replication servers
                        2. "Base Directory-Relative, Optionally Alias-Backed": local file, managed by Sente and kept inside the library bundle
                        3. "File URL": local file, not managed by Sente. In this case the URL is provided as plain text
                    A TEMPORARY solution is to actively select the first local copy-->
                <!-- column 0: reference UUID; column 1: attachment UUID; column 2: location UUID. -->
                <!-- only the latter is unique in this file; thus there should be one <tss:attachmentReference> per unique combination of reference UUID and attachment UUID. In case of more than one location UUID, they will have more than one <URL> child -->
                <!-- if attachments are kept in a synced folder Sente prefixes a private URI scheme "syncii:" that needs to be dereferenced at some point -->
                <tss:attachmentReference>
                    <xsl:attribute name="xml:id" select="concat('uuid_', $v_attachment-uuid)"/>
                    <!-- this is redundant since <tss:notes> is a direct child of the <tss:reference> this attribute refers to -->
<!--                    <xsl:attribute name="correspReference" select="concat('#uuid_', $p_reference-uuid)"/>-->
                    <xsl:attribute name="type" select="$v_type"/>
                    <xsl:attribute name="editor" select="$v_editor"/>
                    <xsl:attribute name="when-iso" select="$v_date-edited"/>
                    <name>
                        <xsl:value-of select="$v_name"/>
                    </name>
                    <!-- test if there is more than one location UUID for this attachment -->
                    <xsl:for-each-group group-by="value[@column = '2']"
                        select="$v_attachment-location/self::row">
                        <URL>
                            <!-- write location UUID to xml:id -->
                            <xsl:attribute name="xml:id"
                                select="concat('uuid_', current-grouping-key())"/>
                            <!-- add custom attribute for location type -->
                            <xsl:attribute name="storageMethod" select="value[@column = '3']"/>
                            <!-- location data is provided, at least, in three ways:
                            1. plain text string of a local file path
                            2. Base64 encoded Apple plist XML files for local relative paths inside the file bundle and earlier sync versions
                            3. Base64 encoded JSON data: for the latest iteration of the sync server
                            -->
                            <xsl:variable name="v_location" select="value[@column = '4']"/>
                            <xsl:choose>
                                <!-- test if the location is provided as Base64 encoded XML or as plain text string -->
                                <xsl:when test="starts-with($v_location, 'PD94bWwg')">
                                    <!-- problem with bin: and saxon: extensions: they do not work in the free Saxon HE -->
                                    <xsl:choose>
                                        <xsl:when test="$p_limited-to-saxon-he = true()">
                                            <xsl:attribute name="type" select="'base64'"/>
                                            <xsl:value-of select="$v_location"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:variable name="v_plist-as-string"
                                                select="bin:decode-string(xs:base64Binary(value[@column = '4']))"/>
                                            <xsl:variable name="v_relative-file-path"
                                                select="substring-after(substring-before($v_plist-as-string, '&lt;/string'), 'string&gt;')"/>
                                            <xsl:value-of
                                                select="concat($v_base-url, 'Attachments/', $v_relative-file-path)"
                                            />
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:when>
                                <!-- here could follow some transformation of the JSON, but this provides only the file names, which we will most likely already know -->
                                <xsl:otherwise>
                                    <xsl:value-of select="$v_location"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </URL>
                    </xsl:for-each-group>
                </tss:attachmentReference>
            </xsl:for-each>
        </tss:attachments>
    </xsl:template>
    <xsl:template name="t_generate-authors">
        <!-- the template takes a reference UUID as input and queries the Author.xml file for any rows relating to this reference -->
        <xsl:param name="p_reference-uuid"/>
        <tss:authors>
            <xsl:for-each
                select="$v_file-authors/table/rows/row[value[@column = '0'] = $p_reference-uuid]">
                <tss:author role="{value[@column='5']}">
                    <tss:surname>
                        <xsl:value-of select="value[@column = '2']"/>
                    </tss:surname>
                    <tss:forenames>
                        <xsl:value-of select="value[@column = '3']"/>
                    </tss:forenames>
                    <tss:initials>
                        <xsl:value-of select="value[@column = '4']"/>
                    </tss:initials>
                </tss:author>
            </xsl:for-each>
        </tss:authors>
    </xsl:template>
    <xsl:template name="t_generate-keywords">
        <!-- the template takes a reference UUID as input and queries the Note.xml file for any rows relating to this reference -->
        <xsl:param name="p_reference-uuid"/>
        <tss:keywords>
            <xsl:for-each
                select="$v_file-keywords/table/rows/row[value[@column = '0'] = $p_reference-uuid]">
                <tss:keyword>
                    <xsl:attribute name="assigner" select="value[@column = '2']"/>
                    <!-- this is redundant since <tss:notes> is a direct child of the <tss:reference> this attribute refers to -->
<!--                    <xsl:attribute name="correspReference" select="concat('#uuid_', $p_reference-uuid)"/>-->
                    <xsl:value-of select="value[@column = '1']"/>
                </tss:keyword>
            </xsl:for-each>
        </tss:keywords>
    </xsl:template>
    <xsl:function name="oap:iso-timestamp">
        <xsl:param name="p_input"/>
        <xsl:value-of select="replace($p_input, '(\d+-\d+-\d+)\s(\d+:\d+:\d+)\s(.+)$', '$1T$2$3')"/>
    </xsl:function>
    <xsl:function name="oap:iso-date">
        <xsl:param name="p_input"/>
        <xsl:value-of select="replace($p_input, '(\d+-\d+-\d+)\s(\d+:\d+:\d+)\s(.+)$', '$1')"/>
    </xsl:function>
</xsl:stylesheet>

<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet  
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:tss="http://www.thirdstreetsoftware.com/SenteXML-1.0"
    xmlns:tei="http://www.tei-c.org/ns/1.0"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:oap="https://openarabicpe.github.io/ns"
    xmlns:b64="https://github.com/ilyakharlamov/xslt_base64" 
    xmlns:bin="http://expath.org/ns/binary"
    version="3.0" exclude-result-prefixes="xs">
    
    <xsl:output method="xml" encoding="UTF-8" indent="yes" omit-xml-declaration="no"  />
<!--    <xsl:include href="xslt_base64-master/base64.xsl"/>-->
    
    <!-- this stylesheet transforms generic XML generated by exporting tables from Sente libraries using SQLiteStudio. Names of the XML files must mirror the names of the SQLite tables -->
    <!-- input is currently a list of reference UUIDs from Reference.xml. Since the stylesheet explicitly pulls in all relevant source files, this can easily be changed to any other source of reference UUIDs -->
    <!-- output is currently a single Sente XML file for all references. Using the modular templates in this stylesheet, this can easily be changed to generate one file for every reference -->
    
    
    <xsl:param name="p_limited-to-saxon-he" select="true()"/>
    <xsl:variable name="v_input-folder" select="replace(base-uri(),'(.+/).+?\.xml','$1')"/>
   
    
    <xsl:template match="/">
        <xsl:result-document href="_output/compiled.TSS.xml">
            <!-- group by PrimaryReferenceUUID in  -->
            <tss:senteContainer>
                <tss:library>
                    <tss:references>
                        <xsl:for-each-group select="table/rows/row" group-by="value[@column='0']">
                            <xsl:call-template name="t_generate-references">
                                <xsl:with-param name="p_reference-uuid" select="current-grouping-key()"/>
                            </xsl:call-template>
                        </xsl:for-each-group>
                    </tss:references>
                </tss:library>
            </tss:senteContainer>
        </xsl:result-document>
    </xsl:template>
    
    <xsl:template name="t_generate-references">
        <xsl:param name="p_reference-uuid"/>
        <xsl:param name="p_input" select="document(concat($v_input-folder,'Reference.xml'))/table/rows/row[value[@column='0']=$p_reference-uuid]"/>
        <xsl:for-each select="$p_input/descendant-or-self::row">
        <tss:reference xml:id="{concat('uuid_',$p_reference-uuid)}">
            <tss:publicationType name="{value[@column='3']}"/>
            <!-- authors -->
            <xsl:call-template name="t_generate-authors">
                <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
            </xsl:call-template>
            <tss:dates>
                <!-- publication dates are stored in three different rows to account for technically false dates -->
                <tss:date type="Publication" year="{value[@column='15']}" month="{value[@column='16']}" day="{value[@column='17']}"/>
                <!-- column 18: date of entry / date, a reference was added to Sente. Very early references do not carry a value  -->
                <xsl:if test="value[@column='18']!=''">
                    <tss:date type="Entry" year="{year-from-date(oap:iso-date(value[@column='18']))}" month="{month-from-date(oap:iso-date(value[@column='18']))}" day="{day-from-date(oap:iso-date(value[@column='18']))}"/>
                </xsl:if>
                <!-- column 19 -->
                <xsl:if test="value[@column='19']!=''">
                    <tss:date type="Modification" year="{year-from-date(oap:iso-date(value[@column='19']))}" month="{month-from-date(oap:iso-date(value[@column='19']))}" day="{day-from-date(oap:iso-date(value[@column='19']))}"/>
                </xsl:if>
                <tss:date type="Retrieval" year="{document(concat($v_input-folder,'SparseAttribute.xml'))/table/rows/row[value[@column='0']=$p_reference-uuid][value[@column='1']='Retrieval year']/value[@column='2']}" month="{document(concat($v_input-folder,'SparseAttribute.xml'))/table/rows/row[value[@column='0']=$p_reference-uuid][value[@column='1']='Retrieval month']/value[@column='2']}" day="{document(concat($v_input-folder,'SparseAttribute.xml'))/table/rows/row[value[@column='0']=$p_reference-uuid][value[@column='1']='Retrieval day']/value[@column='2']}"/>
            </tss:dates>
            <tss:characteristics>
                <tss:characteristic name="UUID">
                    <xsl:value-of select="$p_reference-uuid"/>
                </tss:characteristic>
                <!-- add all relevant bibliographic fields -->
                <!-- we need columns 4-8, 10-11,14, 20 -->
                <xsl:variable name="v_columns" select="'4,5,6,7,8,10,11,14,20'"/>
                <xsl:for-each select="value">
                    <xsl:if test="tokenize($v_columns,',') = @column">
                        <xsl:variable name="v_column-no" select="number(@column)"/>
                        <tss:characteristic name="{ancestor::table/columns/column[$v_column-no +1]/name}">
                            <xsl:value-of select="."/>
                        </tss:characteristic>
                    </xsl:if>
                </xsl:for-each>
                <!-- add aditional fields kept in SparseAttribute.xml, including but not limited to custom fields -->
                <xsl:call-template name="t_generate-characteristics">
                    <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
                </xsl:call-template>
            </tss:characteristics>
            <xsl:call-template name="t_generate-keywords">
                <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
            </xsl:call-template>
            <xsl:call-template name="t_generate-notes">
                <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
            </xsl:call-template>
            <xsl:call-template name="t_generate-attachments">
                <xsl:with-param name="p_reference-uuid" select="$p_reference-uuid"/>
            </xsl:call-template>
        </tss:reference>
        </xsl:for-each>
    </xsl:template>
    
    <xsl:template name="t_generate-characteristics">
        <!-- the template takes a reference UUID as input and queries the SparseAttribute.xml file for any rows relating to this reference -->
        <xsl:param name="p_reference-uuid"/>
        <xsl:param name="p_input" select="document(concat($v_input-folder,'SparseAttribute.xml'))/table/rows/row[value[@column='0']=$p_reference-uuid]"/>
        <xsl:for-each select="$p_input/descendant-or-self::row">
            <!-- exclude certain rows -->
            <xsl:if test="not(value[@column='1']=('Retrieval year', 'Retrieval month', 'Retrieval day'))">
                <tss:characteristic name="{value[@column='1']}">
                    <xsl:value-of select="value[@column='2']"/>
                </tss:characteristic>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    
    <xsl:template name="t_generate-notes">
        <!-- the template takes a reference UUID as input and queries the Note.xml file for any rows relating to this reference -->
         <xsl:param name="p_reference-uuid"/>
        <xsl:param name="p_input" select="document(concat($v_input-folder,'Note.xml'))/table/rows/row[value[@column='1']=$p_reference-uuid]"/>
        <tss:notes>
            <!-- Sente does not ultimately delete any note. Therefore one has to actively check for the status of a row in column 10: IsDeleted. -->
            <!-- In addition, the Note.xml file also contains all notes attached to references long since deleted, which, however, will not be marked as having been deleted themselves -->
            <xsl:for-each select="$p_input/descendant-or-self::row[value[@column='10']='N']">
                <xsl:variable name="v_color-rgba">
                    <xsl:analyze-string select="value[@column='9']" regex="RGBA.+?\[(.+?)\]">
                        <xsl:matching-substring>
                            <xsl:value-of select="regex-group(1)"/>
                        </xsl:matching-substring>
                    </xsl:analyze-string>
                </xsl:variable>
                <!-- translate rgba to colour names -->
                <xsl:variable name="v_color">
                    <xsl:choose>
                        <xsl:when test="$v_color-rgba = '0.9960784,0.8745098,0,0.2'">
                            <xsl:text>yellow</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '1,0.3137255,0.3137255,0.2'">
                            <xsl:text>red</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '0.3921569,0.627451,0.7843137,0.2'">
                            <xsl:text>blue</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '0.4392157,0.6431373,0.5372549,0.2'">
                            <xsl:text>green</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '0.5764706,0.3137255,0.6196079,0.2'">
                            <xsl:text>purple</xsl:text>
                        </xsl:when>
                        <xsl:when test="$v_color-rgba = '0.9647059,0.572549,0.2509804,0.2'">
                            <xsl:text>orange</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>unknown</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <!-- Sente uses different RGBA values for macOS and iOS. We can therefore establish the OS based on the RGBA value. -->
                <xsl:variable name="v_input-os">
                    <xsl:choose>
                        <xsl:when test="$v_color-rgba = ('0.9960784,0.8745098,0,0.2','1,0.3137255,0.3137255,0.2','0.3921569,0.627451,0.7843137,0.2','0.4392157,0.6431373,0.5372549,0.2','0.5764706,0.3137255,0.6196079,0.2','0.9647059,0.572549,0.2509804,0.2')">
                            <xsl:text>macOS</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>iOS</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose> 
                </xsl:variable>
                <xsl:variable name="v_type">
                    <xsl:analyze-string select="value[@column='9']" regex="Original Selection Mode&quot;:&quot;(.+?)&quot;">
                        <xsl:matching-substring>
                            <xsl:value-of select="lower-case(regex-group(1))"/>
                        </xsl:matching-substring>
                    </xsl:analyze-string>
                </xsl:variable>
                <tss:note 
                    xml:id="{concat('uuid_',value[@column='0'])}"  
                    correspReference="{concat('#uuid_',$p_reference-uuid)}" 
                    correspAttachment="{concat('#uuid_',value[@column='7'])}"
                    editor="{concat('Sente User ',value[@column='14'])}"
                    color="{$v_color}"
                    inputOs="{$v_input-os}">
                    <xsl:attribute name="when-iso">
                        <xsl:value-of select="oap:iso-timestamp(value[@column='11'])"/>
                    </xsl:attribute>
                    <!-- some css based on the JSON data stream -->
                        <xsl:choose>
                            <xsl:when test="$v_type='text'">
                                <xsl:attribute name="style">
                                <xsl:text>display:inline-block;</xsl:text>
                                <xsl:text>background-color: rgba(</xsl:text><xsl:value-of select="$v_color-rgba"/><xsl:text>);</xsl:text>
                                </xsl:attribute>
                            </xsl:when>
                            <xsl:when test="$v_type='region'">
                                <xsl:attribute name="style">
                                    <!-- border radius and stroke width are always the same -->
                                <xsl:text>display:block; border-style:solid; border-radius: 3px; border-width: 4px; </xsl:text>
                                <xsl:text>border-color: rgba(</xsl:text><xsl:value-of select="$v_color-rgba"/><xsl:text>);</xsl:text>
                                </xsl:attribute>
                            </xsl:when>
                        </xsl:choose>
                    <title><xsl:value-of select="value[@column='2']"/></title>
                    <comment><xsl:value-of select="value[@column='5']"/></comment>
                    <quotation><xsl:value-of select="value[@column='4']"/></quotation>
                    <pages><xsl:value-of select="value[@column='3']"/></pages>
                    <!-- custom elements mirroring the column name in the SQLite source -->
                    <!-- column 8: position in attached file -->
                    <locationInAttachedFile>
                        <xsl:value-of select=" value[@column='8']"/>
                    </locationInAttachedFile>
                    <!-- column 9: annotation details; JSON including geometry, position on page, colour, strike etc. -->
                    <annotationDetails>
                        <xsl:value-of select=" value[@column='9']"/>
                    </annotationDetails>
                </tss:note>
            </xsl:for-each>
        </tss:notes>
    </xsl:template>
    
    <xsl:template name="t_generate-attachments">
        <!-- the template takes a reference UUID as input and queries the Attachment.xml file for any rows relating to this reference -->
        <xsl:param name="p_reference-uuid"/>
        <xsl:param name="p_input" select="document(concat($v_input-folder,'Attachment.xml'))/table/rows/row[value[@column='0']=$p_reference-uuid]"/>
        <tss:attachments>
            <!-- Sente does not ultimately delete any attachment reference from Attachment.xml. Therefore one has to actively check for the status of a row in column 6: IsDeleted. -->
            <xsl:for-each select="$p_input/descendant-or-self::row[value[@column='6']='N']">
                <xsl:variable name="v_attachment-uuid" select="value[@column='1']"/>
                <xsl:variable name="v_attachment-location" select="document(concat($v_input-folder,'AttachmentLocation.xml'))/table/rows/row[value[@column='1']=$v_attachment-uuid]"/>
                <!-- if attachments are kept in a synced folder Sente prefixes a private URI scheme "syncii:" that needs to be dereferenced at some point -->
                <tss:attachmentReference
                xml:id="{concat('uuid_',$v_attachment-uuid)}"
                correspReference="{concat('#uuid_',$p_reference-uuid)}"
                type="{value[@column='4']}"
                editor="{concat('Sente User ',value[@column='13'])}">
                    <xsl:attribute name="when-iso">
                        <xsl:value-of select="oap:iso-timestamp(value[@column='8'])"/>
                    </xsl:attribute>
                    <name><xsl:value-of select="value[@column='2']"/></name>
                    <URL>
                        <!-- test if the location is provided as Base64 encoded XML or as plain text string -->
                        <xsl:choose>
                            <xsl:when test="starts-with($v_attachment-location/descendant-or-self::row/value[@column='4'],'PD94bWwg')">
                                <!-- translate the relevant bit in base64 to string using xslt 1.
                                Problem: this only works with ASCII and we have Unicode data -->
                                <!--<xsl:variable name="v_path-as-base64">
                                    <xsl:value-of select="substring-after($v_attachment-location/descendant-or-self::row/value[@column='4'],'V5PgoJPHN0cmlu')"/>
                                </xsl:variable>
                                <xsl:variable name="v_path-as-string">
                                    <xsl:call-template name="b64:decode">
                                        <xsl:with-param name="base64String" select="$v_path-as-base64"/>
                                    </xsl:call-template>
                                </xsl:variable>-->
                                <!-- problem with bin: and saxon: extensions: they do not work in the free Saxon HE -->
                                <xsl:choose>
                                    <xsl:when test="$p_limited-to-saxon-he = true()">
                                        <xsl:attribute name="type" select="'base64'"/>
                                        <!--<xsl:value-of select="substring-after(substring-before($v_path-as-string,'&lt;'),'&gt;')"/>-->
                                        <xsl:value-of select="$v_attachment-location/descendant-or-self::row/value[@column='4']"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:variable name="v_plist-as-string">
                                            <xsl:value-of select="bin:decode-string(xs:base64Binary($v_attachment-location/descendant-or-self::row/value[@column='4']))"/>
                                        </xsl:variable>
                                        <xsl:variable name="v_relative-file-path">
                                            <xsl:value-of select="substring-after(substring-before($v_plist-as-string,'&lt;/string'),'string&gt;')"/>
                                        </xsl:variable>
                                        <xsl:variable name="v_base-url">
                                            <xsl:value-of select="substring-before(document(concat($v_input-folder,'LibraryProperty.xml'))/table/rows/row[value[@column='0']='Library Location']/value[@column='1'],'primaryLibrary.sente601')"/>
                                        </xsl:variable>
                                        <xsl:value-of select="concat($v_base-url,'Attachments/',$v_relative-file-path)"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                                
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="$v_attachment-location/descendant-or-self::row/value[@column='4']"/>
                            </xsl:otherwise>
                    </xsl:choose>
                    </URL>
            </tss:attachmentReference>
<!--            <tss:attachmentReference type="Portable Document Format (PDF)"/>-->
            </xsl:for-each>
        </tss:attachments>
    </xsl:template>
    
    <xsl:template name="t_generate-authors">
        <!-- the template takes a reference UUID as input and queries the Author.xml file for any rows relating to this reference -->
        <xsl:param name="p_reference-uuid"/>
        <xsl:param name="p_input" select="document(concat($v_input-folder,'Author.xml'))/table/rows/row[value[@column='0']=$p_reference-uuid]"/>
        <tss:authors>
            <xsl:for-each select="$p_input/descendant-or-self::row">
                <tss:author role="{value[@column='5']}">
                    <tss:surname><xsl:value-of select="value[@column='2']"/></tss:surname>
                    <tss:forenames><xsl:value-of select="value[@column='3']"/></tss:forenames>
                    <tss:initials><xsl:value-of select="value[@column='4']"/></tss:initials>
                </tss:author>
            </xsl:for-each>
        </tss:authors>
    </xsl:template>
    
    <xsl:template name="t_generate-keywords">
        <!-- the template takes a reference UUID as input and queries the Note.xml file for any rows relating to this reference -->
        <xsl:param name="p_reference-uuid"/>
        <xsl:param name="p_input" select="document(concat($v_input-folder,'Keyword.xml'))/table/rows/row[value[@column='0']=$p_reference-uuid]"/>
        <tss:keywords>
            <xsl:for-each select="$p_input/descendant-or-self::row">
                <tss:keyword
                    assigner="{value[@column='2']}"
                    correspReference="{concat('#uuid_',$p_reference-uuid)}">
                   <xsl:value-of select="value[@column='1']"/>
                </tss:keyword>
            </xsl:for-each>
        </tss:keywords>
    </xsl:template>
    
    <xsl:function name="oap:iso-timestamp">
        <xsl:param name="p_input"/>
        <xsl:value-of select="replace($p_input,'(\d+-\d+-\d+)\s(\d+:\d+:\d+)\s(.+)$','$1T$2$3')"/>
    </xsl:function>
    <xsl:function name="oap:iso-date">
        <xsl:param name="p_input"/>
        <xsl:value-of select="replace($p_input,'(\d+-\d+-\d+)\s(\d+:\d+:\d+)\s(.+)$','$1')"/>
    </xsl:function>
    
</xsl:stylesheet>